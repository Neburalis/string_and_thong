#ifndef ENHANCED_STRING_H
#define ENHANCED_STRING_H

#include <unistd.h>

/**
 * @brief Подсчитывает количество вхождений символа в строке ограниченной длины
 * @param haystack Указатель на строку для поиска
 * @param haystack_len Длина строки haystack
 * @param needle Искомый символ
 * @return Количество найденных символов или -1 при ошибке
 */
ssize_t count_needle_in_haystack(char * haystack, const size_t haystack_len, const char needle);

/**
 * @brief Заменяет все вхождения символа src на символ dst в строке ограниченной длины
 * @param haystack Указатель на строку для замены
 * @param haystack_len Длина строки haystack
 * @param src Заменяемый символ
 * @param dst Символ для замены
 * @return Количество замененных символов или -1 при ошибке
 */
ssize_t replace_needle_in_haystack
    (char * haystack, const size_t haystack_len, const char src, const char dst);

/**
 * @brief Перемещает указатель к ближайшему алфавитному символу относительно текущей позиции
 *
 * Алфавитный символ определяется как символ, для которого isalpha() возвращает ненулевое
 * значение (в соответствии с текущей локалью). Функция изменяет переданный указатель
 * на месте.
 *
 * @param ptr Адрес указателя на текущую позицию в строке; по завершении будет указывать
 *            на найденный алфавитный символ
 * @param backword Направление поиска: 0 — вперёд (к концу строки), ненулевое — назад (к началу)
 * @note Ожидается, что в выбранном направлении располагается валидная область памяти
 *       внутри одной нуль-терминированной строки; выход за её границы приводит к
 *       неопределённому поведению.
 */
void move_ptr_to_first_alpha_symbol(const char ** ptr, int backword);

/**
 * @brief Перемещает указатель к ближайшему символу, отличному от пробельного, относительно текущей позиции
 *
 * Пробельные символы определяются как символы, для которых isspace() возвращает ненулевое
 * значение (в соответствии с текущей локалью). Функция изменяет переданный указатель
 * на месте.
 *
 * @param ptr Адрес указателя на текущую позицию в строке; по завершении будет указывать
 *            на первый непробельный символ
 * @param backword Направление поиска: 0 — вперёд (к концу строки), ненулевое — назад (к началу)
 * @note Ожидается, что в выбранном направлении располагается валидная область памяти
 *       внутри одной нуль-терминированной строки; выход за её границы приводит к
 *       неопределённому поведению.
 */
void move_ptr_to_first_not_space_symbol(const char ** ptr, int backword);

/**
 * @brief Проверяет, что строка не является NULL и не пустой
 * @param str Указатель на строку для проверки
 * @return Ненулевое значение если строка не пустая, 0 если пустая или NULL
 */
int is_not_empty(const char *str);

/**
 * @brief Вычисляет хэш строки по алгоритму djb2 (Dan Bernstein)
 *
 * Данный алгоритм (k=33) был впервые описан Дэном Бернстейном в comp.lang.c.
 * Другая версия этого алгоритма (предпочитаемая Бернстейном) использует XOR:
 * hash(i) = hash(i - 1) * 33 ^ str[i];
 * Магия числа 33 (почему оно работает лучше многих других констант)
 * так и не была должным образом объяснена.
 *
 * @param str Указатель на строку для хэширования
 * @return Хэш-значение строки
 */
unsigned long djb2(const unsigned char *str);

/**
 * @brief Вычисляет хэш строки по алгоритму sdbm
 *
 * Данный алгоритм был создан для библиотеки базы данных sdbm
 * (публично доступная реимплементация ndbm).
 * Было обнаружено, что он хорошо перемешивает биты, обеспечивая лучшее
 * распределение ключей и меньшее количество коллизий.
 * Это также хорошая универсальная хэш-функция с хорошим распределением.
 * Фактическая функция: hash(i) = hash(i - 1) * 65599 + str[i];
 * Ниже представлена более быстрая версия, используемая в gawk.
 * Магическая простая константа 65599 (2^6 + 2^16 - 1) была выбрана
 * экспериментально среди множества различных констант.
 * Это один из алгоритмов, используемых в Berkeley DB и других местах.
 *
 * @param str Указатель на строку для хэширования
 * @return Хэш-значение строки
 */
unsigned long sdbm(const const char * str);

#endif // ENHANCED_STRING_H